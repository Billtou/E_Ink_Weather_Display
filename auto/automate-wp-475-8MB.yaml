substitutions:
  name: "automate-wp-475"
  friendly_name: "AUTOMATE WP-475"
  upper_devicename: "ESP32 7.5in RED BLACK WHITE AND YELLOW"
  project_name: "Taiwan Smart Home Technology.AUTOMATE WP-475"
  project_version: "2025.05.2"  
  timezone: "Asia/Taipei"
  default_city_name: "臺中市"
  default_town_name: "南屯區"
  default_api: "CWA-E02B6C42-9A1B-4FD7-B5A6-BA605006274E"
  default_latitude: "24.153935542067238"
  default_longitude: "120.63569437196482"
  default_update_interval: "10s"
  
external_components:
  - source: github://tsunglung/esphome_epaper
    components: [ display, waveshare_epaper ]  
    
#----------------------------------------------------
  - source: github://parkghost/esphome-cwa-town-forecast
    refresh: 0s
    components: [cwa_town_forecast]
    
packages:
  fonts_in: !include e_pagper/fonts.yaml
  entity_in: !include e_pagper/select_sensor.yaml
  basic_in: !include e_pagper/basic.yaml
  gebug_in: !include e_pagper/debug.yaml
#-----------------------------------------------------

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  # name_add_mac_suffix: True
  project:
    name: "${project_name}"
    version: "${project_version}"
  comment: ${upper_devicename}    
  on_boot:
    priority: 600
    then:
      - light.turn_on:
          id: behind_led
          effect: "Rainbow Effect"  
      - delay: 5s
      - light.turn_off:
          id: behind_led          

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: arduino

psram:
  mode: quad
  speed: 80MHz  
  
sun:
  latitude: $default_latitude 
  longitude: $default_longitude 
  
color:
  - id: color_white
    red: 100%
    green: 100%
    blue: 100%
  - id: color_red
    red: 100%
    green: 0%
    blue: 0%
  - id: color_yellow
    red: 100%
    green: 100%
    blue: 0%
  - id: color_black
    red: 0%
    green: 0%
    blue: 0%
      
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO48
    num_leds: 1
    id: behind_led
    rmt_channel: 0
    chipset: ws2812
    name: "Behind LED"
    icon: mdi:led-outline
    effects:
      - addressable_rainbow:
          name: "Rainbow Effect"
          speed: 10
          width: 10
      - addressable_lambda:
          name: "Rainy Red Pulse"
          update_interval: 100ms
          lambda: |-
            static int brightness = 0;
            static int direction = 5;
            brightness += direction;
            if (brightness >= 255) {
              brightness = 255;
              direction = -5;
            } else if (brightness <= 25) {
              brightness = 35;
              direction = 5;
            }
            it[0] = Color(brightness, 0, 0);  // 紅色
globals:
  - id: town_forecast_3d_init
    type: bool
    initial_value: "false"

  - id: town_forecast_7d_init
    type: bool
    initial_value: "false"

time:
  - platform: sntp
    id: esp_time
    timezone: $timezone
    servers:
      - time1.google.com
      - time2.google.com
      - time3.google.com
    on_time:
      - cron: "0 15 0,6,9,12,15,18,21 * * *"
        then:
          if:
            condition:
              and:
                - wifi.connected:
                - time.has_time:
                - switch.is_on: auto_update
            then:
              - logger.log: "定時觸發 refresh_panel_full_update"
              - script.execute: refresh_panel_full_update

cwa_town_forecast:
  - api_key: !lambda return id(cwa_api_key).state;
    id: town_forecast_3d
    city_name: !lambda return id(city_name).state;
    town_name: !lambda return id(town_name).state;
    mode: 3-DAYS
    retain_fetched_data: true
    time_to: 1d
    on_data_change:
      - lambda: |-
          id(town_forecast_3d_init) = true;

  - api_key: !lambda return id(cwa_api_key).state;
    id: town_forecast_7d
    city_name: !lambda return id(city_name).state;
    town_name: !lambda return id(town_name).state;
    mode: 7-DAYS
    retain_fetched_data: true
    on_data_change:
      - lambda: |-
          id(town_forecast_7d_init) = true;

text:
  - platform: template
    id: town_name
    name: "Town Name 鄉鎮區"
    icon: mdi:town-hall
    optimistic: true
    min_length: 0
    max_length: 20
    mode: text
    restore_value: true
    initial_value: $default_town_name
    entity_category: "config"

  - platform: template
    id: cwa_api_key
    name: "CWA API Key 授權碼"
    icon: mdi:key-chain-variant
    optimistic: true
    min_length: 0
    max_length: 42
    mode: text
    restore_value: true
    initial_value: $default_api
    entity_category: "config"    

button:
  - platform: restart
    name: "Restart 重開機"
  - platform: template
    name: "Update Forecast 3D"
    on_press:
      - script.execute: update_forecast_3d
    internal: true

  - platform: template
    name: "Update Forecast 7D"
    on_press:
      - script.execute: update_forecast_7d
    internal: true

  - platform: template
    name: "Update Forecast"
    on_press:
      then:
        - script.execute: update_forecast_all
    internal: true

  - platform: template
    name: "Dump Forcast 3D Data"
    on_press:
      - lambda: |-
          id(town_forecast_3d)->get_data().dump();
    internal: true

  - platform: template
    name: "Dump Forcast 7D Data"
    on_press:
      - lambda: |-
          id(town_forecast_7d)->get_data().dump();
    internal: true

  - platform: template
    name: "Analyze Forcast Data"
    on_press:
      - script.execute: analyze_data
    internal: true

  - platform: template
    name: 'Refresh Panel 更新頁面'
    id: refresh_weather_panel
    icon: mdi:sync
    on_press:
      then:
        if:
          condition:
            and:
              - wifi.connected:
              - time.has_time:
              # - switch.is_on: auto_update
          then:
            - logger.log: "執行update_forecast_3d 腳本"
            - script.execute: update_forecast_3d
            - delay: 2s
            - logger.log: "執行update_forecast_3d 腳本"
            - script.wait: update_forecast_3d
            - delay: 2s
            - logger.log: "執行update_forecast_3d 腳本"
            - script.execute: update_forecast_7d
            - delay: 2s
            - logger.log: "執行update_forecast_3d 腳本"
            - script.wait: update_forecast_7d
            - delay: 2s
            - logger.log: "執行 analyze_data 腳本"
            - script.execute: analyze_data
            - delay: 2s
            - script.wait: analyze_data
            - logger.log: "等待5秒"
            - delay: 2s
            - logger.log: "執行 更新畫面動作"
            - component.update: my_display

  - platform: template
    name: "Defaul 恢復出廠值"
    id: restore_defaults
    icon: mdi:restore
    on_press:
      - select.set:
          id: city_name
          option: "臺中市"
      - select.set:
          id: options_windows
          option: "sun_and_moon"
      - select.set:
          id: forecast_mode
          option: "daily_temp_high_low"
      - text.set:
          id: town_name
          value: "南屯區"
      - text.set:
          id: cwa_api_key
          value: "CWA-E02B6C42-9A1B-4FD7-B5A6-BA605006274E"
      - switch.turn_on: auto_update
      - switch.turn_on: rainy_red_led
    entity_category: "config"

switch:
  - platform: template
    name: "Auto Refresh Panel 自動更新頁面"
    id: auto_update
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # 開機後預設開啟
    icon: mdi:update
  - platform: template
    name: "Rainy Effect Light 下雨亮紅燈"
    id: rainy_red_led
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # 開機後預設開啟   
    icon: mdi:led-on 

script:
  - id: update_forecast_3d
    then:
      - component.update: town_forecast_3d

  - id: update_forecast_7d
    then:
      - component.update: town_forecast_7d

  - id: update_forecast_all
    then:
      - script.execute: update_forecast_3d
      - delay: 3s
      - script.wait: update_forecast_3d
      - delay: 3s
      - script.execute: update_forecast_7d
      - delay: 3s
      - script.wait: update_forecast_7d
      - delay: 3s


  - id: refresh_panel_full_update
    mode: single
    then:
      - if:
          condition:
            and:
              - wifi.connected:
              - time.has_time:
          then:
            - logger.log: "執行 update_forecast_3d 腳本"
            - script.execute: update_forecast_3d
            - delay: 2s

            - logger.log: "等待 update_forecast_3d 結束"
            - script.wait: update_forecast_3d
            - delay: 2s

            - logger.log: "執行 update_forecast_7d 腳本"
            - script.execute: update_forecast_7d
            - delay: 2s

            - logger.log: "等待 update_forecast_7d 結束"
            - script.wait: update_forecast_7d
            - delay: 2s

            - logger.log: "執行 analyze_data 腳本"
            - script.execute: analyze_data
            - delay: 2s

            - logger.log: "等待 analyze_data 結束"
            - script.wait: analyze_data

            - logger.log: "等待 5 秒"
            - delay: 5s

            - logger.log: "執行 更新畫面動作"
            - component.update: my_display

  - id: analyze_data
    then:
      - lambda: |-
          using namespace cwa_town_forecast;
          auto forecast_3d_data = id(town_forecast_3d).get_data();
          auto forecast_7d_data = id(town_forecast_7d).get_data();
          bool fallback = true;

          auto now = id(esp_time).now();
          if(!now.is_valid()){
            ESP_LOGW("forecast", "Current time is not valid");
            return;
          }

          ESP_LOGI("forecast", "Current time: %s", now.strftime("%Y-%m-%d %H:%M:%S").c_str());
          ESP_LOGI("forecast", "Current Forecast(Nearly 1-3 hours):");
          ESP_LOGI("forecast", "  LocationsName: %s", forecast_3d_data.locations_name.c_str());
          ESP_LOGI("forecast", "  LocationName: %s", forecast_3d_data.location_name.c_str());
          ESP_LOGI("forecast", "  Temperature: %s°C", forecast_3d_data.find_value(ElementValueKey::TEMPERATURE, fallback, now.to_c_tm()).c_str()); //需要
          ESP_LOGI("forecast", "  Apparent Temperature: %s°C", forecast_3d_data.find_value(ElementValueKey::APPARENT_TEMPERATURE, fallback, now.to_c_tm()).c_str()); //需要
          ESP_LOGI("forecast", "  Relative Humidity: %s%%", forecast_3d_data.find_value(ElementValueKey::RELATIVE_HUMIDITY, fallback, now.to_c_tm()).c_str()); //需要
          ESP_LOGI("forecast", "  Probability Of Precipitation: %s%%", forecast_3d_data.find_value(ElementValueKey::PROBABILITY_OF_PRECIPITATION, fallback, now.to_c_tm()).c_str()); //需要
          ESP_LOGI("forecast", "");

          ESP_LOGI("forecast", "Today's Forecast(From now until midnight):");
          std::tm start = mktm(now.year, now.month, now.day_of_month, 0, 0, 0);
          std::tm end = mktm(now.year, now.month, now.day_of_month, 23, 59, 59);
          auto min_max = forecast_3d_data.find_min_max_values(ElementValueKey::TEMPERATURE, start, end);
          ESP_LOGI("forecast", "  Temperature: %.0f-%.0f °C", min_max.first, min_max.second);
          min_max = forecast_3d_data.find_min_max_values(ElementValueKey::APPARENT_TEMPERATURE, start, end);
          ESP_LOGI("forecast", "  Apparent Temperature: %.0f-%.0f °C", min_max.first, min_max.second);
          min_max = forecast_3d_data.find_min_max_values(ElementValueKey::RELATIVE_HUMIDITY, start, end);
          ESP_LOGI("forecast", "  Relative Humidity: %.0f-%.0f %%", min_max.first, min_max.second);
          ESP_LOGI("forecast", "");

          // see https://www.cwa.gov.tw/V8/C/W/Town/Town.html?TID=6500300
          ESP_LOGI("forecast", "Current Forecast(Day/Night):");
          ESP_LOGI("forecast", "  LocationsName: %s", forecast_7d_data.locations_name.c_str());
          ESP_LOGI("forecast", "  LocationName: %s", forecast_7d_data.location_name.c_str());
          ESP_LOGI("forecast", "  Avg Temperature: %s°C", forecast_7d_data.find_value(ElementValueKey::TEMPERATURE, fallback, now.to_c_tm()).c_str());  //需要
          ESP_LOGI("forecast", "  Avg Relative Humidity: %s%%", forecast_7d_data.find_value(ElementValueKey::RELATIVE_HUMIDITY, fallback, now.to_c_tm()).c_str()); //需要
          ESP_LOGI("forecast", "  Max Temperature: %s°C", forecast_7d_data.find_value(ElementValueKey::MAX_TEMPERATURE, fallback, now.to_c_tm()).c_str());  //需要
          ESP_LOGI("forecast", "  Min Temperature: %s°C", forecast_7d_data.find_value(ElementValueKey::MIN_TEMPERATURE, fallback, now.to_c_tm()).c_str());  //需要
          ESP_LOGI("forecast", "  Max Apparent Temperature: %s°C", forecast_7d_data.find_value(ElementValueKey::MAX_APPARENT_TEMPERATURE, fallback, now.to_c_tm()).c_str()); //需要
          ESP_LOGI("forecast", "  Min Apparent Temperature: %s°C", forecast_7d_data.find_value(ElementValueKey::MIN_APPARENT_TEMPERATURE, fallback, now.to_c_tm()).c_str()); //需要
          ESP_LOGI("forecast", "  Probability Of Precipitation: %s%%", forecast_7d_data.find_value(ElementValueKey::PROBABILITY_OF_PRECIPITATION, fallback, now.to_c_tm()).c_str()); //需要
          ESP_LOGI("forecast", "  UV Index: %s", forecast_7d_data.find_value(ElementValueKey::UV_INDEX, fallback, now.to_c_tm()).c_str()); //需要
          ESP_LOGI("forecast", "");

          // see https://www.cwa.gov.tw/V8/C/W/Town/Town.html?TID=6500300
          ESP_LOGI("forecast", "7-Day Forecast(Day/Night):");
          {
            const auto &record = forecast_7d_data;
            auto now_tm = now.to_c_tm();
            for (int d = 0; d < 7; ++d) {
              // noon entry
              std::tm noon = now_tm;
              noon.tm_mday += d;
              noon.tm_hour = 12; noon.tm_min = 0; noon.tm_sec = 0;
              std::mktime(&noon);
              auto esp_noon = tm_to_esptime(noon);
              auto date_str = esp_noon.strftime("%Y-%m-%d");
              auto weekday = esp_noon.strftime("%a");
              std::string min_val = record.find_value(ElementValueKey::MIN_TEMPERATURE, false, noon);
              std::string max_val = record.find_value(ElementValueKey::MAX_TEMPERATURE, false, noon);
              std::string icon = record.find_value(ElementValueKey::WEATHER_ICON, false, noon);
              std::string rain = record.find_value(ElementValueKey::PROBABILITY_OF_PRECIPITATION, false, noon);
              ESP_LOGI("forecast", "  %s %s %s: icon %s, rain %s%%, min %s°C, max %s°C",
                        date_str.c_str(),weekday.c_str(),  "(Day)  ", icon.c_str(), rain.c_str(), min_val.c_str(), max_val.c_str());
            }
          }
# Pins for Waveshare ePaper ESP Board
spi:
  clk_pin: GPIO2
  mosi_pin: GPIO1

# Now render everything on the ePaper screen.
display:  
  - platform: waveshare_epaper
    cs_pin: GPIO42
    dc_pin: GPIO41
    busy_pin: 
      number: GPIO39
      inverted: true
    reset_pin: GPIO40
    reset_duration: 10ms
    # model: 7.5in-gooddisplay
    model: 7.5in-w21-gooddisplay
    full_update_every: 10
    update_interval: never
    id: my_display
    rotation: 0°   
    lambda: |-
      int width = it.get_width();
      int height = it.get_height();
      it.fill(id(color_white));  //全螢幕刷新成白色
      const std::map<std::string, std::string> ICON_NAME_TO_UNICODE_MAP = {
          {"sunny","\U000F0599"},
          {"partly-cloudy","\U000F0595"},
          {"cloudy","\U000F0590"},
          {"pouring","\U000F0596"},
          {"partly-rainy","\U000F0F33"},
          {"rainy","\U000F0597"},
          {"lightning-rainy","\U000F067E"},
          {"partly-lightning","\U000F0F32"},
          {"snowy-rainy","\U000F067F"},
          {"fog","\U000F0591"},
          {"snowy","\U000F0598"},
          {"night","\U000F0594"},
          {"night-partly-cloudy","\U000F0F31"},
          {"sync","\U000F04E6"}
      };

      const std::map<std::string, bool> WEATHER_ICON_HIGHLIGHT {
        {"sunny", false},
        {"partly-cloudy", false},
        {"cloudy", false},
        {"pouring", true},
        {"partly-rainy", true},
        {"rainy", true},
        {"lightning-rainy", true},
        {"partly-lightning", true},
        {"snowy-rainy", true},
        {"fog", true},
        {"snowy", true},
        {"night", false},
        {"night-partly-cloudy", false},
      };      

      auto now = id(esp_time).now();
      std::tm now_tm = now.to_c_tm();
      // --------------------------------------安全讀取------------------------------------------------------



      //****************************************** 日曆 *****************************************************
      // 獲取當前月份的數字
      int month_num = id(esp_time).now().month; 

      // 使用 strftime 取得當前星期數字 (1-7)，其中 1 表示星期一,7 表示星期日
      char weekday_char[2];
      id(esp_time).now().strftime(weekday_char, sizeof(weekday_char), "%u");

      // 轉換星期數字字元為整數，調整為 0 (星期日) 到 6 (星期六)
      int weekday_num = atoi(weekday_char) % 7; // 星期日從 7 轉為 0

      // 判斷是否為週末（週六或週日）
      bool is_weekend = (weekday_num == 0 || weekday_num == 6);

      // 設定背景顏色
      it.filled_rectangle(10, 3, 165, 230, is_weekend ? id(color_red) : id(color_yellow));

      // 對應中文月份
      std::string month_names[] = {
          "一月", "二月", "三月", "四月", "五月", "六月", 
          "七月", "八月", "九月", "十月", "十一", "十二"
      };
      // 確保月份值有效，並選擇對應的中文月份
      std::string month = (month_num >= 1 && month_num <= 12) ? month_names[month_num - 1] : "未知月份";
      // 顯示中文月份（週末用白色，平日用黑色）
      it.print(95, 85, id(font_NotoSansHK_Bold), is_weekend ? id(color_white) : id(color_black), TextAlign::BOTTOM_CENTER, month.c_str());

      // 顯示日期（週末用白色，平日用紅色）
      it.strftime(95, 60, id(font_day_large), is_weekend ? id(color_white) : id(color_red), TextAlign::TOP_CENTER, "%d", id(esp_time).now());      

      // 繪製水平線（週末用白色，平日用紅色）
      it.filled_rectangle(15, 165, 156, 6, is_weekend ? id(color_white) : id(color_red));

      // 中文星期名稱陣列
      std::string weekday_names[] = {
          "星期日", "星期一", "星期二", "星期三", 
          "星期四", "星期五", "星期六"
      };

      // 確保有效性，並選擇對應的中文星期名稱
      std::string weekday = (weekday_num >= 0 && weekday_num <= 6) ? weekday_names[weekday_num] : "未知星期";

      // 顯示中文星期名稱（週末用白色，平日用黑色）
      it.print(15, 169, id(font_jyuugothic_Bold), is_weekend ? id(color_white) : id(color_black), TextAlign::TOP_LEFT, weekday.c_str());
      
      //***************************************** 24節氣 文字 *****************************************************
      int room1_icon_x=15;
      int room1_icon_y=235;
      int icon_gap_y=43;
      int room1_icon_x_gap=90;
      int room1_data_y=room1_icon_y+2;
      int data_gap_y=30;
      int room2_name_y=260;
      // 季節對應的文字表
      int month_num_1 = id(esp_time).now().month; 
      // 對應中文季節
      std::string month_names_1[] = {
          "立春 雨水 迎端月", "驚蟄 春分 迎花月", "清明 穀雨 迎桐月", "立夏 小滿 迎梅月", "芒種 夏至 迎莆月", "大暑 小暑 迎荔月", 
          "立秋 處暑 迎巧月", "白鷺 秋分 迎桂月", "寒露 霜降 迎菊月", "立冬 小雪 迎陽月", "大雪 冬至 迎葭月", "大寒 小寒 迎臘月"
      };
      // 確保季節值有效，並選擇對應的中文季節
      std::string month_1 = (month_num_1 >= 1 && month_num_1 <= 12) ? month_names_1[month_num_1 - 1] : "-";
      // 顯示中文季節
      it.print(19, room2_name_y + 7, id(font_jyuugothic_Light_1), id(color_black), TextAlign::BOTTOM_LEFT, month_1.c_str()); 
      
      //***************************************** 天氣描述文字 *****************************************************
      it.printf(19, room2_name_y + 3, id(font_jyuugothic_Bold_2), id(color_red), TextAlign::TOP_LEFT, "%s", (id(d7_weather).state == "unknown") ? "-" : id(d7_weather).state.c_str());      

      //***************************************** sidebar *****************************************************      
      //sensor icon
      int room2_icon_y=280;
      int room2_icon_gap=2;
      it.print(room1_icon_x-5, (room2_icon_y+icon_gap_y)-room2_icon_gap, id(font_jyuugothic_Bold_3),id(color_yellow), TextAlign::CENTER_LEFT, "\U000F0765"); //園底圖
      it.print(room1_icon_x, (room2_icon_y+icon_gap_y)-room2_icon_gap, id(icon_room),id(color_red), TextAlign::CENTER_LEFT, "\U000F058E"); //濕度圖標
      it.print(room1_icon_x + room1_icon_x_gap+3-5, (room2_icon_y+icon_gap_y)-room2_icon_gap, id(font_jyuugothic_Bold_3),id(color_yellow), TextAlign::CENTER_LEFT, "\U000F0765"); //園底圖
      it.print(room1_icon_x + room1_icon_x_gap+3, (room2_icon_y+icon_gap_y)-room2_icon_gap, id(icon_room),id(color_red), TextAlign::CENTER_LEFT, "\U000F054A"); //雨傘
      it.print(room1_icon_x-5, (room2_icon_y+icon_gap_y+icon_gap_y)-room2_icon_gap, id(font_jyuugothic_Bold_3), id(color_yellow), TextAlign::CENTER_LEFT, "\U000F0765"); //園底圖
      it.print(room1_icon_x, (room2_icon_y+icon_gap_y+icon_gap_y)-room2_icon_gap, id(icon_room), id(color_red), TextAlign::CENTER_LEFT, "\U000F0E02"); // 低溫圖標
      it.print((room1_icon_x + room1_icon_x_gap+3)-5, (room2_icon_y+icon_gap_y+icon_gap_y)-room2_icon_gap, id(font_jyuugothic_Bold_3),id(color_yellow), TextAlign::CENTER_LEFT, "\U000F0765"); //園底圖
      it.print(room1_icon_x + room1_icon_x_gap+3, (room2_icon_y+icon_gap_y+icon_gap_y)-room2_icon_gap, id(icon_room),id(color_red), TextAlign::CENTER_LEFT, "\U000F0E03"); //高溫圖標
      it.print(room1_icon_x-5, (room2_icon_y+icon_gap_y+icon_gap_y+icon_gap_y)-room2_icon_gap, id(font_jyuugothic_Bold_3),id(color_yellow),TextAlign::CENTER_LEFT, "\U000F0765"); //園底圖
      it.print(room1_icon_x, (room2_icon_y+icon_gap_y+icon_gap_y+icon_gap_y)-room2_icon_gap, id(icon_room),id(color_red),TextAlign::CENTER_LEFT, "\U000F17FE"); //UV圖標
      it.print(room1_icon_x-5, (room2_icon_y+icon_gap_y+icon_gap_y+icon_gap_y+icon_gap_y)-room2_icon_gap, id(font_jyuugothic_Bold_3),id(color_yellow), TextAlign::CENTER_LEFT,"\U000F0765"); //園底圖
      it.print(room1_icon_x, (room2_icon_y+icon_gap_y+icon_gap_y+icon_gap_y+icon_gap_y)-room2_icon_gap, id(icon_room),id(color_red), TextAlign::CENTER_LEFT,"\U000F15FA"); //wind_speed風速圖標

      //data 
      auto format_value = [](float value, const char* fmt, const char* fallback) -> std::string {
        if (std::isnan(value)) return std::string(fallback);
        char buf[32];
        snprintf(buf, sizeof(buf), fmt, value);
        return std::string(buf);
      };
      
      // 濕度
      std::string humidity = format_value(id(d7_relative_humidity).state, "%.0f%%", "--%");
      // 降雨機率
      std::string rainy = format_value(id(d7_probability_of_precipitation_12h).state, "%.0f%%", "--%");      
      // 最高溫
      std::string temp_hi = format_value(id(d7_max_temperature).state, "%.0f°%", "--°");
      // 最低溫
      std::string temp_lo = format_value(id(d7_min_temperature).state, "%.0f°%", "--°");
      // UV + 文字說明
      std::string uv_value = format_value(id(d7_uv_index).state, "%.0f uv%", "-- uv") + id(d7_uv_exposure_level).state;
      // 風速 + 風向
      std::string wind_value = format_value(id(d7_win_speed).state, "%.0f m/s%", "-- m/s") + id(d7_wind_direction).state;

      // 顯示輸出到電子紙
      it.print((room1_icon_x + room1_icon_x_gap)-data_gap_y, room2_icon_y + icon_gap_y, id(font_jyuugothic_Light), id(color_black), TextAlign::CENTER, humidity.c_str());  // 濕度
      it.print((room1_icon_x + room1_icon_x_gap+ room1_icon_x_gap)-data_gap_y, room2_icon_y + icon_gap_y, id(font_jyuugothic_Light), id(color_black), TextAlign::CENTER, rainy.c_str()); // 降雨機率
      it.print((room1_icon_x + room1_icon_x_gap)-data_gap_y, room2_icon_y + icon_gap_y + icon_gap_y, id(font_jyuugothic_Light), id(color_black), TextAlign::CENTER, temp_lo.c_str()); // 最低溫
      it.print((room1_icon_x + room1_icon_x_gap+ room1_icon_x_gap)-data_gap_y, room2_icon_y + icon_gap_y + icon_gap_y, id(font_jyuugothic_Light), id(color_black), TextAlign::CENTER, temp_hi.c_str());    // 最高溫
      it.print((room1_icon_x + room1_icon_x_gap+ room1_icon_x_gap)-5, room2_icon_y + icon_gap_y + icon_gap_y + icon_gap_y, id(font_jyuugothic_Light), id(color_black), TextAlign::CENTER_RIGHT, uv_value.c_str()); // UV
      it.print((room1_icon_x + room1_icon_x_gap+ room1_icon_x_gap)-5, room2_icon_y + icon_gap_y + icon_gap_y + icon_gap_y + icon_gap_y, id(font_jyuugothic_Light), id(color_black), TextAlign::CENTER_RIGHT, wind_value.c_str()); // 風速

      //************************ last_updated and city name tow name IP address ************************
      char info_text[64];
      // 幫每個字串先取出值，並做 null 安全處理
      std::string ip      = id(ip_address_display).has_state() ? id(ip_address_display).state : "-";
      std::string city    = id(d7_city).has_state() ? id(d7_city).state : "-";
      std::string town    = id(d7_town).has_state() ? id(d7_town).state : "-";
      std::string updated = id(d7_last_updated).has_state() ? id(d7_last_updated).state : "-";
      // 組合文字
      snprintf(info_text, sizeof(info_text), "%s %s %s %s", ip.c_str(), city.c_str(), town.c_str(), updated.c_str());
      // 顯示
      it.print(795, 0, id(font_small_new), id(color_black), TextAlign::TOP_RIGHT, info_text);
      
      //************************ TODAY weather and  temperature ************************

      // 取得氣象圖示鍵值，如果 sensor 沒有 state 就設為空字串
      std::string weather_icon_key = id(d7_weather_icon).has_state() ? id(d7_weather_icon).state : "sync";

      // 嘗試從 icon map 中取得對應 unicode 字元，找不到則用預設值 "sync"
      auto icon_map_it = ICON_NAME_TO_UNICODE_MAP.find(weather_icon_key);
      std::string unicode_icon;

      if (icon_map_it != ICON_NAME_TO_UNICODE_MAP.end()) {
        unicode_icon = icon_map_it->second;
      } else {
        ESP_LOGW("weather", "未找到圖示 key: '%s'，使用預設 'sync'", weather_icon_key.c_str());
        unicode_icon = ICON_NAME_TO_UNICODE_MAP.at("sync");  // 保證 sync 存在
      }

      // 顯示 icon
      it.printf(400, 5, id(icon_today), id(color_black), TextAlign::TOP_CENTER, unicode_icon.c_str());

      //---------------------------------------------------------------------------------------------------------
      // 平均溫度與體感溫度
      char avgtemp[16];
      char max_appa[16];
      char min_appa[16];

      if (isnan(id(d7_avg_temperature).state)) {
        snprintf(avgtemp, sizeof(avgtemp), "--°c");
      } else {
        snprintf(avgtemp, sizeof(avgtemp), "%.0f°c", id(d7_avg_temperature).state);
      }

      if (isnan(id(d7_max_apparent_temperature).state)) {
        snprintf(max_appa, sizeof(max_appa), "--°");
      } else {
        snprintf(max_appa, sizeof(max_appa), "%.0f°", id(d7_max_apparent_temperature).state);
      }

      if (isnan(id(d7_min_apparent_temperature).state)) {
        snprintf(min_appa, sizeof(min_appa), "--°");
      } else {
        snprintf(min_appa, sizeof(min_appa), "%.0f°", id(d7_min_apparent_temperature).state);
      }

      // 舒適度描述，安全取值
      std::string max_comfort = id(d7_max_comfort_index_description).has_state() ? id(d7_max_comfort_index_description).state : "-";
      std::string min_comfort = id(d7_min_comfort_index_description).has_state() ? id(d7_min_comfort_index_description).state : "-";

      // 顯示資料
      it.printf(780, 50, id(font_today_temp), id(color_black), TextAlign::TOP_RIGHT, avgtemp);
      it.print(690, 185, id(font_jyuugothic_Bold_2), id(color_red), TextAlign::BOTTOM_RIGHT, min_comfort.c_str());
      it.print(690, 220, id(font_jyuugothic_Bold_2), id(color_red), TextAlign::BOTTOM_RIGHT, max_comfort.c_str());
      it.print(730, 185, id(font_jyuugothic_Bold_2), id(color_red), TextAlign::BOTTOM_LEFT, min_appa);
      it.print(730, 220, id(font_jyuugothic_Bold_2), id(color_red), TextAlign::BOTTOM_LEFT, max_appa);

      // 體感 icon
      it.print(725, 177, id(icon_room), id(color_black), TextAlign::BOTTOM_RIGHT, "\U000F053F");
      it.print(725, 210, id(icon_room), id(color_black), TextAlign::BOTTOM_RIGHT, "\U000F053F");

      //************************ SUN AND MOON  ************************
      // Print sunrise and sun setting dates
      if (id(options_windows).state.c_str() == std::string("sun_and_moon"))  {
        it.printf(615, 230, id(sunset_down_up), id(color_black),TextAlign::CENTER_RIGHT, "\U000F059A");
        it.print(628, 235, id(font_rooms_name),id(color_black), TextAlign::CENTER_LEFT, id(sun_sunrise).state.c_str());
        it.printf(615, 265, id(sunset_down_up), id(color_black),TextAlign::CENTER_RIGHT, "\U000F050E");
        it.print(628, 270, id(font_rooms_name),id(color_black), TextAlign::CENTER_LEFT, id(sun_sunset).state.c_str()); 
        std::map<std::string, std::string> moon_icon_map
          {
            {"new_moon", "\U000F0F64"},
            {"full_moon", "\U000F0F62"},
            {"waxing_crescent", "\U000F0F67"},
            {"first_quarter", "\U000F0F61"},
            {"waxing_gibbous", "\U000F0F68"},
            {"waning_gibbous", "\U000F0F66"},
            {"lightning-rainy", "\U000F067E"},
            {"last_quarter", "\U000F0F63"},
            {"waning_crescent", "\U000F0F65"},
          };   
        it.printf(750, 250, id(icon_big_moon), id(color_black),TextAlign::CENTER,  "\U000F0765");   // moon背景色
        it.printf(750, 250, id(icon_sun_and_moon), id(color_white),TextAlign::CENTER,  moon_icon_map[id(moon_phase).state.c_str()].c_str());   
      }

      //************************ FORECAST ************************
      // SELECT ID: forecast_mode     
      // 星期顯示明天開始6天的內容, 時間顯示下次開始6次內容
      // - daily_temp_high_low    --> 7d(noon)      星期  氣象圖標  MAX_TEMPERATURE             MIN_TEMPERATURE
      // - daily_feel_high_low    --> 7d(noon)      星期  氣象圖標  MAX_APPARENT_TEMPERATURE    MIN_APPARENT_TEMPERATURE   
      // - daily_avg_temp_humid   --> 7d(noon)      星期  氣象圖標  TEMPERATURE                 RELATIVE_HUMIDITY   
      // - daily_avg_temp_rainy   --> 7d(noon)      星期  氣象圖標  TEMPERATURE                 PROBABILITY_OF_PRECIPITATION
      // - hourly_temp_humid      --> 3D(近6 data)  時間  氣象圖標  TEMPERATURE                 RELATIVE_HUMIDITY
      // - hourly_temp_rainy      --> 3D(近6 data)  時間  氣象圖標  TEMPERATURE                 PROBABILITY_OF_PRECIPITATION
      // - hourly_feel_rainy      --> 3D(近6 data)  時間  氣象圖標  APPARENT_TEMPERATURE        PROBABILITY_OF_PRECIPITATION
      //---------------------------------------------------------
      int forecast_x=300;
      int forecast_y=320;
      int forecast_icon_gap=40;
      int forecast_data_gap=90;
      //int forecast_x_gap=90;      

      // forecast matrix drawing
        {
          const char *weekdays[] = {"日", "一", "二", "三", "四", "五", "六"};

          using namespace cwa_town_forecast;
          int left_offset = 255;
          int top_offset = 310;
          int area_w = width - left_offset;
          int area_h = height - top_offset;
          std::string mode = id(forecast_mode).state;

          bool is_daily = id(forecast_mode).state.rfind("daily", 0) == 0;
          int cols = 6;
          int cell_w = area_w / cols;
          int cell_h = area_h / 4;
          // draw vertical separators
          for (int i = 1; i < cols; i++) {
            it.line(left_offset + i * cell_w, 345, left_offset + i * cell_w, 465, id(color_black));  
          }
          auto now = id(esp_time).now();
          std::tm now_tm = now.to_c_tm();
          auto data7 = id(town_forecast_7d).get_data();
          auto data3 = id(town_forecast_3d).get_data();

          for (int c = 0; c < cols; c++) {
            int sx = left_offset + c * cell_w;
            int sy = top_offset;
            std::tm tm_ref = now_tm;
            std::string v1, v2;

            // row1: label
            std::string label;
            if (is_daily) {
              auto day_start = now_tm;
              if (std::mktime(&day_start) < std::mktime(&data7.start_time)) {
                day_start = data7.start_time;
              }
              tm_ref = day_start;
              tm_ref.tm_mday += c + 1;
              tm_ref.tm_hour = 12; tm_ref.tm_min = 0; tm_ref.tm_sec = 0;
              std::mktime(&tm_ref);
              auto esp = tm_to_esptime(tm_ref);
              
              label = std::string("週") + weekdays[tm_to_esptime(tm_ref).day_of_week - 1];
            } else {
              auto hour_start = now_tm;
              if (std::mktime(&hour_start) < std::mktime(&data3.start_time)) {
                hour_start = data3.start_time;
              }            
              tm_ref = hour_start;
              tm_ref.tm_hour += c; tm_ref.tm_min = 0; tm_ref.tm_sec = 0;
              label = tm_to_esptime(tm_ref).strftime("%I%p");
            }
            it.printf(sx + cell_w / 2, sy + cell_h / 2, id(font_jyuugothic_Light), id(color_black), TextAlign::CENTER, label.c_str());
            sy += cell_h;
            // row2: icon
            std::string icon_key;
            if (is_daily) {
              icon_key = data7.find_value(ElementValueKey::WEATHER_ICON, false, tm_ref);
            } else{
              // use hourly time
              icon_key = data3.find_value(ElementValueKey::WEATHER_ICON, false, tm_ref);
            }

            // 將圖示名稱轉換為對應的 Unicode 字符

            std::string unicode;
            if (ICON_NAME_TO_UNICODE_MAP.count(icon_key)) {
                unicode = ICON_NAME_TO_UNICODE_MAP.at(icon_key);
            } else {
                unicode = "";
            }

            bool should_highlight = false;
            if (WEATHER_ICON_HIGHLIGHT.count(icon_key)) {
                should_highlight = WEATHER_ICON_HIGHLIGHT.at(icon_key);
            }

            // 繪製背景（只有需要高亮的圖示才顯示）
            if (should_highlight) {
                it.printf(
                    sx + cell_w / 2,        // x 位置
                    sy + cell_h / 2,        // y 位置
                    id(icon_forecast_bg),   // 背景圖示字型
                    id(color_red),          // 黃色背景
                    TextAlign::CENTER,      // 居中對齊
                    "\U000F0765"            // 背景圖示的 Unicode
                );
            }

            // 繪製前景天氣圖示
            it.printf(
                sx + cell_w / 2,            // x 位置（與背景相同）
                sy + cell_h / 2,            // y 位置（與背景相同）
                id(icon_forecast),          // 天氣圖示字型
                should_highlight ? id(color_white) : id(color_red), // 顏色選擇
                TextAlign::CENTER,          // 居中對齊
                unicode.c_str()             // 天氣圖示的 Unicode
            );

            sy += cell_h;
            // rows 3 & 4: values
            std::string mode = id(forecast_mode).state;

            if (mode == "daily_temp_high_low") {
              v1 = data7.find_value(ElementValueKey::MIN_TEMPERATURE, false, tm_ref) + "°";
              v2 = data7.find_value(ElementValueKey::MAX_TEMPERATURE, false, tm_ref) + "°";
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F0E02"); // 溫度計下    
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap + forecast_icon_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F0E03"); // 溫度計上          
            } else if (mode == "daily_feel_high_low") {
              v1 = data7.find_value(ElementValueKey::MIN_APPARENT_TEMPERATURE, false, tm_ref) + "°";
              v2 = data7.find_value(ElementValueKey::MAX_APPARENT_TEMPERATURE, false, tm_ref) + "°";
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F053F"); // 衣服
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap + forecast_icon_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F053F"); // 衣服              
            } else if (mode == "daily_avg_temp_humid") {
              v1 = data7.find_value(ElementValueKey::TEMPERATURE, false, tm_ref) + "°";
              v2 = data7.find_value(ElementValueKey::RELATIVE_HUMIDITY, false, tm_ref) + "%%";
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F1B0F"); // 溫度平均
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap + forecast_icon_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F058E"); // 濕度              
            } else if (mode == "daily_avg_temp_rainy") {
              v1 = data7.find_value(ElementValueKey::TEMPERATURE, false, tm_ref) + "°";
              v2 = data7.find_value(ElementValueKey::PROBABILITY_OF_PRECIPITATION, false, tm_ref) + "%%";
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F1B0F"); // 溫度平均
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap + forecast_icon_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F054A"); // 下雨    
            } else if (mode == "daily_avg_temp_uv") {
              v1 = data7.find_value(ElementValueKey::TEMPERATURE, false, tm_ref) + "°";
              v2 = data7.find_value(ElementValueKey::UV_INDEX, false, tm_ref) + "%";
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F1B0F"); // 溫度平均
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap + forecast_icon_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F17FE"); // UV    
            } else if (mode == "hourly_temp_humid") {
              v1 = data3.find_value(ElementValueKey::TEMPERATURE, false, tm_ref) + "°";
              v2 = data3.find_value(ElementValueKey::RELATIVE_HUMIDITY, false, tm_ref) + "%%";
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F050F"); // 溫度計
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap + forecast_icon_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F058E"); // 濕度              
            } else if (mode == "hourly_temp_rainy") {
              v1 = data3.find_value(ElementValueKey::TEMPERATURE, false, tm_ref) + "°";
              v2 = data3.find_value(ElementValueKey::PROBABILITY_OF_PRECIPITATION, false, tm_ref) + "%%";
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F050F"); // 溫度計
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap + forecast_icon_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F054A"); // 下雨              
            } else if (mode == "hourly_feel_rainy") {
              v1 = data3.find_value(ElementValueKey::APPARENT_TEMPERATURE, false, tm_ref) + "°";
              v2 = data3.find_value(ElementValueKey::PROBABILITY_OF_PRECIPITATION, false, tm_ref) + "%%";
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F053F"); // 衣服
              it.printf(forecast_x - 60, forecast_y + forecast_data_gap + forecast_icon_gap, id(icon_room), id(color_red), TextAlign::CENTER, "\U000F054A"); // 下雨              
            }
            it.printf(sx + cell_w / 2, sy + cell_h / 2, id(font_medium), id(color_black), TextAlign::CENTER, v1.c_str());
            sy += cell_h;
            if (mode == "daily_avg_temp_uv") {
                
              std::string v = v2;
              size_t i = 0;
              // 尋找開頭的第一個數字（可能含 +/-)
              while (i < v.size() && !((v[i] >= '0' && v[i] <= '9') || v[i] == '-' || v[i] == '+')) i++;

              size_t start = i;
              // 讀取數字部分（含小數點）
              while (i < v.size() && ((v[i] >= '0' && v[i] <= '9') || v[i] == '.')) i++;

              std::string num_str = (start < v.size()) ? v.substr(start, i - start) : "0";
              float uv = std::stof(num_str);

              if (uv > 7) {
                it.printf((sx + cell_w / 2)+1, sy + (cell_h / 2)-5, id(icon_forecast_bg_uv), id(color_red), TextAlign::CENTER, "\U000F0765");
                it.printf(sx + cell_w / 2, sy + cell_h / 2, id(font_medium), id(color_white), TextAlign::CENTER, v2.c_str());
              } else {
                it.printf(sx + cell_w / 2, sy + cell_h / 2, id(font_medium), id(color_black), TextAlign::CENTER, v2.c_str());
              }

            } else {
            it.printf(sx + cell_w / 2, sy + cell_h / 2, id(font_medium), id(color_black), TextAlign::CENTER, v2.c_str());
            }
          }
        }
